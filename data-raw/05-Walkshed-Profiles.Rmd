---
title: "Profiling Walksheds"
author: "Antonio Paez"
date: "`r Sys.Date()`"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this document we profile the ped sheds based on their network attributes.

WARNING: Rerunning this notebook can cause the training of the evolutionary trees to deviate slightly from the reported results. 

# Preliminaries

Load packages:

```{r warning=FALSE, message=FALSE}
library(broom) # Convert Statistical Objects into Tidy Tibbles
library(dplyr) # A Grammar of Data Manipulation
library(evtree) # Evolutionary Learning of Globally Optimal Trees
library(ggparty) # 'ggplot' Visualizations for the 'partykit' Package
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(glue) # Interpreted String Literals
library(gt) # Easily Create Presentation-Ready Display Tables
library(patchwork) # The Composer of Plots
library(tidyr) # Tidy Messy Data
library(tree) # Classification and Regression Trees
library(sf) # Simple Features for R
library(skimr) # Compact and Flexible Summaries of Data
library(SOMbrero) # SOM Bound to Realize Euclidean and Relational Outputs
library(stringr) # Simple, Consistent Wrappers for Common String Operations
library(units) # Measurement Units for R Vectors
library(vaccHamilton) # A Data Package to Estimate Accessibility of Vaccination Sites in Hamilton, ON
```

Load data:
```{r}
load(file = glue::glue(here::here(), "/data/amenities_walkshed_da.rda"))
load(file = glue::glue(here::here(), "/data/hamilton_net.rda"))
load(file = glue::glue(here::here(), "/data/urban_hammer_da.rda"))
data("urban_types")
load(file = glue::glue(here::here(), "/data/walksheds_da.rda"))
load(file = glue::glue(here::here(), "/data/walksheds_da_net_vars.rda"))
load(file = glue::glue(here::here(), "/data/walksheds_validation.rda"))
load(file = glue::glue(here::here(), "/data/walksheds_validation_net_vars.rda"))
```

Bind the centroid and non-centroid walksheds (da and validations, but bound could be used in more imaginative ways for cross-validation, for example):
```{r}
walksheds <- bind_rows(walksheds_da,
                       walksheds_validation) |>
  mutate(origin_type = rep(c("centroid", "non-centroid"), each = nrow(walksheds_da)))
```

Obtain training and validation datasets by sampling from centroid and non-centroid walksheds:
```{r}
seed <- 3626425

# slice_sample() will select one of two rows for each DA at random
walksheds_train <- walksheds |>
  group_by(GeoUID) |>
  slice_sample(prop = 0.5)

# The antijoin will keep the rows in walksheds that do not appear in walksheds_train
walksheds_test <- walksheds |>
  anti_join(walksheds_train |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))
```

Bind the centroid and non-centroid dataframes with walkshed network variables (da and validations):
```{r}
walksheds_net_vars <- bind_rows(walksheds_da_net_vars,
                                walksheds_validation_net_vars) |>
  mutate(origin_type = rep(c("centroid", "non-centroid"), each = nrow(walksheds_da)))
```

Now filter from the network variables to obtain training and test datasets:
```{r}
walksheds_train_net_vars <- walksheds_net_vars |>
  semi_join(walksheds_train |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))

walksheds_test_net_vars <- walksheds_net_vars |>
  semi_join(walksheds_test |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))
```

Check these dataframes for NAs, inf, or other anomalies:
```{r}
summary(walksheds_train_net_vars)
summary(walksheds_test_net_vars)
```

The girth is problematic. There is a single NA in `transitivity` in the test dataset.

## Classification tree

The aim is to train a classification tree to profile urban and suburban walksheds based on the attributes of the network. We need to drop 1 observation that has an NA in `transitivity`:

```{r}
d <- walksheds_train_net_vars |>
  select(-girth) |>
  drop_na() |>
  mutate(normalized_motifs_3 = motifs_3/n_edges,
         normalized_motifs_4 = motifs_4/n_edges)

d_test <- walksheds_test_net_vars |>
  select(-girth) |>
  drop_na() |>
  mutate(normalized_motifs_3 = motifs_3/n_edges,
         normalized_motifs_4 = motifs_4/n_edges)
```

We use a technique with evolutionary trees - an alternative to classification trees that is less affected by the greediness of the algorithm. Since evolutionary trees have some randomness (for the initial values), we can try several to find whether there are patterns. 

Bunch of trees with random seeds. First, make sure that the seeds are reproducible:
```{r}
n_trees <- 30 # select number of trees
set.seed(98732475)
seeds <- sample.int(1000000, n_trees)
```

Traaaain!
```{r}
counter <- 0 
trees <- list()
for(i in seeds){
  counter <- counter + 1
  #set.seed(seeds[counter])
  #tree_name <- glue::glue("tree{counter}")
  trees[[counter]] <- evtree(Type ~ ., 
                             data = d |> 
                               select(-c(GeoUID, motifs_3, motifs_4, n_edges, n_nodes, origin_type)),
                             control = evtree.control(seed = seeds[counter]))
}
```

Name the trees in the list above:
```{r}
named_trees <- data.frame(t = "evtree ", count = c(1:n_trees)) |>
  mutate(t = glue::glue("{t}{count}"))

names(trees) <- named_trees$t
```

Check the attributes of the trees:
```{r}
trees
```

The frequency of variables in this set of tree is as follows:

Variable            | Number of trees where it appears
--------------------| --------------------------------
edge_density        | IIIII IIIII IIIII IIIII IIIII IIIII 
normalized_motifs_3 | IIIII IIIII IIIII IIIII IIIII IIIII 
diameter            | IIIII II
transitivity        | II
mean_distance       | II
normalized_motifs_4 | I

IIIII IIIII IIIII IIIII IIIII IIIII

The pattern is dominated by edge_density and normalized_motifs_3, and this has been the case after repeating this procedure several times. By now I must have trained over 150 trees.

There is something about reproducing the trained trees; after restarting the computer, using the same seed does not replicate the trees; after doing this process several times, the results are very similar, but to avoid problems with slightly different trees being produced every time, save the results of this run):
```{r eval=FALSE}
# WARNING: Run only if you wish to replace the file with the results used in the report
# Save to `data` folder
save(trees,
     file = glue::glue(here::here(), "/data/trees.rda"),
     compress = "xz")
```

Examine missclassification in training dataset. The missclassification is the proportion of times that the predicted class is different from the observed class. The evaluation function uses the missclassification rate but penalizes by complexity (number of nodes in the tree):
```{r}
mc <- function(obj) 1 - mean(predict(obj) == d$Type)


evalfun <- function(obj) 2 * nrow(d) * mc(obj) + width(obj) * log(nrow(d))

#trees <- list("evtree" = tree1, "rpart" = rp, "ctree" = ct, "rpart2" = rp2, "ctree2" = ct2)
#trees <- list("evtree 1" = tree1, "evtree 2" = tree2, "evtree 3" = tree3, "evtree 4" = tree4)

mc_train <- round(sapply(trees, function(obj) c("misclassification" = mc(obj), "evaluation function" = evalfun(obj))), digits = 7)
mc_train
```

Examine missclassificationon the test data:
```{r}
mc <- function(obj) 1 - mean(predict(obj, newdata = d_test) == d_test$Type)


evalfun <- function(obj) 2 * nrow(d_test) * mc(obj) + width(obj) * log(nrow(d_test))

#trees <- list("evtree" = tree1, "rpart" = rp, "ctree" = ct, "rpart2" = rp2, "ctree2" = ct2)
#trees <- list("evtree 1" = tree1, "evtree 2" = tree2, "evtree 3" = tree3, "evtree 4" = tree4)

mc_test <- round(sapply(trees, function(obj) c("misclassification" = mc(obj), "evaluation function" = evalfun(obj))), digits = 7)
mc_test
```

The tree that best balances the evaluation function in the train and test datasets is `tree26`:
```{r}
(mc_train[2,] + mc_test[2,])/2
```

There are several ties, but are actually variations of the same model. Choose Tree 4:
```{r}
best_evtree <- trees[[4]]
```

Plot the tree:
```{r}
# Round the labels of the edges. The relevant information is in a dataframe produced by ggparty()
ggparty_plot <- best_evtree |>
  ggparty()

# Round the number of digits and keep the inequality signs
ggparty_data <- ggparty_plot$data |>
  mutate(breaks_label = paste0(substr(breaks_label, 4, 5), 
                               substr(breaks_label,10, 15)),
         splitvar = case_when(splitvar == "edge_density" ~ "Edge Density",
                              splitvar == "transitivity" ~ "Transitivity",
                              splitvar == "normalized_motifs_3" ~ "Normalized Motifs (3)",
                              is.na(splitvar) ~ NA))

# Replace the dataframe in the ggplot object
ggparty_plot$data <- ggparty_data 

ggparty_plot +
  geom_edge() +
  geom_node_splitvar(id = "inner", size = 3) +
  # parse should be set to FALSE so the labels do not try to parse the inequality signs
  geom_edge_label(mapping = aes(label = breaks_label),
                  parse = FALSE,
                  size = 2.5) +
  # # pass list to gglist containing all ggplot components we want to plot for each
  # # (default: terminal) node
  geom_node_plot(gglist = list(geom_bar(aes(x = "", fill = Type),
                                        position = position_fill()),
                               xlab(""),
                               ylab(""),
                               scale_fill_manual(name = "Urban fabric type",
                                                 values = c("#FDAE61", "#1A9850")),
                               theme(axis.text.y = element_blank(),
                                     panel.background = element_rect(fill = NA),
                                     axis.ticks = element_blank()))) +
  geom_node_label(line_list = list(aes(label = paste0("Leaf ", ifelse(id >= 6, id - 3, id - 2)))),
                  line_gpar = list(list(size = 7, parse = F)),
                  ids = "terminal",
                  nudge_x = 0.02,
                  nudge_y = -0.4)
```

The leaves are as follows:

Leaf        | Character
------------|----------
Leaf 1      | Suburban
Leaf 2      | Urban
Leaf 3      | Suburban
Leaf 4      | Urban

Check the break labels of `tree4` to round:

```{r}
ggparty(best_evtree)$data$breaks_label
```

Use the classification tree to add classes to train data:
```{r add-classification-to-train-data}

d <- d |>
  mutate(leaf = case_when(edge_density < 0.00590599876314162 & normalized_motifs_3 < 0.865853658536585  ~ "Leaf 1",
                          edge_density < 0.00590599876314162 & normalized_motifs_3 >= 0.865853658536585 ~ "Leaf 2",
                          edge_density >= 0.00590599876314162 & normalized_motifs_3 < 0.967078189300412 ~ "Leaf 3",
                          edge_density >= 0.00590599876314162 & normalized_motifs_3 >= 0.967078189300412 ~ "Leaf 4") ,
         leaf = factor(leaf))
```

Use the classification tree to add classes to test data:
```{r add-classification-to-test-data}
d_test <- d_test |>
  mutate(leaf = case_when(edge_density < 0.00590599876314162 & normalized_motifs_3 < 0.865853658536585  ~ "Leaf 1",
                          edge_density < 0.00590599876314162 & normalized_motifs_3 >= 0.865853658536585 ~ "Leaf 2",
                          edge_density >= 0.00590599876314162 & normalized_motifs_3 < 0.967078189300412 ~ "Leaf 3",
                          edge_density >= 0.00590599876314162 & normalized_motifs_3 >= 0.967078189300412 ~ "Leaf 4") ,
         leaf = factor(leaf))
```

Join the classes to walksheds:
```{r}
walksheds_train <- walksheds_train |> 
  left_join(d |>
              st_drop_geometry() |>
              select(GeoUID,
                     Type,
                     leaf),
            by = c("GeoUID", 
                   "Type"))
```

Examples of networks and walksheds by leaf.

Leaf 1 (Urban):
```{r plot-leaf-1}
set.seed(29919)

walkshed_leaf_1 <- walksheds_train |> 
  ungroup () |>
  filter(leaf == "Leaf 1") |>
  slice_sample(n = 1)

leaf_1_plot <- hamilton_net$edges |>
  st_intersection(walkshed_leaf_1)

leaf_1_plot <- hamilton_net$edges |>
  filter(edge_index %in% leaf_1_plot$edge_index) |>
  st_transform(crs = st_crs(urban_types))

walkshed_leaf_1 <- walkshed_leaf_1 |> 
  st_transform(crs = st_crs(urban_types))

# Find the center of the bounding box; we'll use it to plot on a false origin and fixed extent
max_x_1 <- st_bbox(leaf_1_plot)[3] - st_bbox(leaf_1_plot)[1]
max_y_1 <- st_bbox(leaf_1_plot)[4] - st_bbox(leaf_1_plot)[2]
center_1 <- c(max_x_1/2 + st_bbox(leaf_1_plot)[1], max_y_1/2 + st_bbox(leaf_1_plot)[2])

ggplot() +
  geom_sf(data = walkshed_leaf_1,
          color = "#FDAE61",
          fill = "#FDAE61") +
  geom_sf(data = leaf_1_plot) +
  ggtitle("Walkshed in Leaf 1 (Suburban)") +
  theme_void()
```

Leaf 2 (Urban):
```{r plot-leaf-2}
set.seed(29919)

walkshed_leaf_2 <- walksheds_train |> 
  ungroup () |>
  filter(leaf == "Leaf 2") |>
  slice_sample(n = 1)

leaf_2_plot <- hamilton_net$edges |>
  st_intersection(walkshed_leaf_2)

leaf_2_plot <- hamilton_net$edges |>
  filter(edge_index %in% leaf_2_plot$edge_index) |>
  st_transform(crs = st_crs(urban_types))

walkshed_leaf_2 <- walkshed_leaf_2 |> 
  st_transform(crs = st_crs(urban_types))

# Find the center of the bounding box; we'll use it to plot on a false origin and fixed extent
max_x_2 <- st_bbox(leaf_2_plot)[3] - st_bbox(leaf_2_plot)[1]
max_y_2 <- st_bbox(leaf_2_plot)[4] - st_bbox(leaf_2_plot)[2]
center_2 <- c(max_x_2/2 + st_bbox(leaf_2_plot)[1], max_y_2/2 + st_bbox(leaf_2_plot)[2])

ggplot() +
  geom_sf(data = walkshed_leaf_2,
          color = "#1A9850",
          fill = "#1A9850") +
  geom_sf(data = leaf_2_plot) +
  ggtitle("Walkshed in Leaf 2 (Urban)") +
  theme_void()
```

Leaf 3 (Urban):
```{r plot-leaf-3}
set.seed(29922)

walkshed_leaf_3 <- walksheds_train |> 
  ungroup () |>
  filter(leaf == "Leaf 3") |>
  slice_sample(n = 1)

leaf_3_plot <- hamilton_net$edges |>
  st_intersection(walkshed_leaf_3)

leaf_3_plot <- hamilton_net$edges |>
  filter(edge_index %in% leaf_3_plot$edge_index) |>
  st_transform(crs = st_crs(urban_types))

walkshed_leaf_3 <- walkshed_leaf_3 |> 
  st_transform(crs = st_crs(urban_types))

# Find the center of the bounding box; we'll use it to plot on a false origin and fixed extent
max_x_3 <- st_bbox(leaf_3_plot)[3] - st_bbox(leaf_3_plot)[1]
max_y_3 <- st_bbox(leaf_3_plot)[4] - st_bbox(leaf_3_plot)[2]
center_3 <- c(max_x_3/2 + st_bbox(leaf_3_plot)[1], max_y_3/2 + st_bbox(leaf_3_plot)[2])

ggplot() +
  geom_sf(data = walkshed_leaf_3,
          color = "#FDAE61",
          fill = "#FDAE61") +
  geom_sf(data = leaf_3_plot) +
  ggtitle("Walkshed in Leaf 3 (Suburban)") +
  theme_void()
```

Leaf 4 (Urban):
```{r plot-leaf-4}
set.seed(29946765)

walkshed_leaf_4 <- walksheds_train |> 
  ungroup () |>
  filter(leaf == "Leaf 4") |>
  slice_sample(n = 1)

leaf_4_plot <- hamilton_net$edges |>
  st_intersection(walkshed_leaf_4)

leaf_4_plot <- hamilton_net$edges |>
  filter(edge_index %in% leaf_4_plot$edge_index) |>
  st_transform(crs = st_crs(urban_types))

walkshed_leaf_4 <- walkshed_leaf_4 |> 
  st_transform(crs = st_crs(urban_types))

# Find the center of the bounding box; we'll use it to plot on a false origin and fixed extent
max_x_4 <- st_bbox(leaf_4_plot)[3] - st_bbox(leaf_4_plot)[1]
max_y_4 <- st_bbox(leaf_4_plot)[4] - st_bbox(leaf_4_plot)[2]
center_4 <- c(max_x_4/2 + st_bbox(leaf_4_plot)[1], max_y_4/2 + st_bbox(leaf_4_plot)[2])

ggplot() +
  geom_sf(data = walkshed_leaf_4,
          color = "#1A9850",
          fill = "#1A9850") +
  geom_sf(data =leaf_4_plot) +
  ggtitle("Walkshed in Leaf 4 (Typically urban)") +
  theme_void()
```

Find the max extent in x and y:
```{r}
max_x <- max(c(max_x_1, max_x_2, max_x_3, max_x_4))
max_y <- max(c(max_y_1, max_y_2, max_y_3, max_y_4))
```

Function to translate the objects to center them at a false origin of zero:
```{r}

leaf_1_gg <- ggplot() +
  geom_sf(data = walkshed_leaf_1,
          color = "#FDAE61",
          fill = "#FDAE61") +
  geom_sf(data = leaf_1_plot) +
  theme_void()

leaf_2_gg <- ggplot() +
  geom_sf(data = walkshed_leaf_2,
          color = "#1A9850",
          fill = "#1A9850") +
  geom_sf(data = leaf_2_plot) +
  theme_void()

leaf_3_gg <- ggplot() +
  geom_sf(data = walkshed_leaf_3,
          color = "#FDAE61",
          fill = "#FDAE61") +
  geom_sf(data = leaf_3_plot) +
  theme_void()

leaf_4_gg <- ggplot() +
  geom_sf(data = walkshed_leaf_4,
          color = "#1A9850",
          fill = "#1A9850") +
  geom_sf(data =leaf_4_plot) +
  theme_void()

```


```{r}
sample_sheds_by_urban_type <- cowplot::plot_grid(leaf_1_gg, leaf_2_gg, leaf_3_gg, leaf_4_gg,
                   nrow = 2, 
                   ncol = 2,
                   labels = c("Leaf 1 (Subrban)", "Leaf 2 (Urban)", "Leaf 3 (Suburban)", "Leaf 4 (Urban)"))

cowplot::save_plot(sample_sheds_by_urban_type,
                   filename = glue::glue(here::here(),"/plots/sample_sheds_by_urban_type.png"),
                   nrow = 2,
                   ncol = 3,
                   base_width = 3.5)

sample_sheds_by_urban_type
```

