---
title: "Which fifteen-minutes neighborhoods are dead-ends? An analysis of the network attributes of fifteen-minute pedsheds"
author:
  - name: Author One
    email: a1@example.com
    affiliation: University One
    correspondingauthor: true
    footnote: 1
  - name: Author Two
    email: a2@example.com
    affiliation: University Two
  - name: Author Three
    email: a3@example.com
    affiliation: University One
    footnote: 2
  - name: Author Four
    email: a4@example.com
    affiliation: University One
    footnote: 2
address:
  - code: University One
    organization: Department
    addressline: 1 main street
    city: City
    state: State
    postcode: 123456
    country: Country
  - code: University Two
    organization: Department
    addressline: 2 main street
    postcode: 2054
    city: City
    country: Country
footnote:
  - code: 1
    text: "This is the first author footnote."
  - code: 2
    text: "Another author footnote."
abstract: |
  Fifteen-minutes neihborhoods, a form of normative chronourbanism based on cumulative opportunities, has aroused interest as a way to reduce the need for motorized travel, and increase the livability, convenience, and health of the public. At the core of this concept is a pedshed, an area defined by the walkable isochrone of the eponymous fifteen minutes. As the idea of fifteen-minutes neighborhoods develops traction in policy and planning circles, it seems timely to revisit the way street network design can support—or obstruct—the stated goal of preserving or creating walkable neighborhoods with essential amenities. In this paper we examine a sample ($n=834$) of fifteen-minutes pedsheds in Hamilton, a medium-sized city in Canada, and how their sizes relate to the attributes of the transportation network. The analysis reveals that network design in suburban Hamilton conspires against the creating of fifteen-minutes neighborhoods. Much of urban Hamilton, in contrast, already has the characteristics of fifteen-minutes neighborhoods. The research points to elements of network design that can help to discriminate between candidate neighborhoods and dead-ends, and that can provide parameters for the design of new developments.

keywords: 
  - Fifteen-minutes neighborhoods
  - Pedshed
  - Walkability
  - Accessibility
  - Network analysis
journal: "Sustainable Cities and Society"
date: "`r Sys.Date()`"
classoption: preprint, 3p, authoryear
bibliography:
  - "`r system('kpsewhich ../bibliography/bibliography.bib', intern=TRUE)`"
linenumbers: false
numbersections: true
# Use a CSL with `citation_package = "default"`
# csl: https://www.zotero.org/styles/elsevier-harvard
output: 
  rticles::elsevier_article:
    keep_tex: true
    citation_package: natbib
---

```{r chunk-setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

```{r load-packages}
library(broom) # Convert Statistical Objects into Tidy Tibbles
library(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'
library(dplyr) # A Grammar of Data Manipulation
library(evtree) # Evolutionary Learning of Globally Optimal Trees
library(ggparty) # 'ggplot' Visualizations for the 'partykit' Package
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(glue) # Interpreted String Literals
library(gt) # Easily Create Presentation-Ready Display Tables
#library(rpart) # Recursive Partitioning and Regression Trees
#library(rpart.plot) # Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'
#library(patchwork) # The Composer of Plots
#library(partykit) # A Toolkit for Recursive Partytioning
library(tidyr) # Tidy Messy Data
#library(tree) # Classification and Regression Trees
library(sf) # Simple Features for R
library(skimr) # Compact and Flexible Summaries of Data
#library(SOMbrero) # SOM Bound to Realize Euclidean and Relational Outputs
library(stringr) # Simple, Consistent Wrappers for Common String Operations
library(units) # Measurement Units for R Vectors
library(vaccHamilton) # A Data Package to Estimate Accessibility of Vaccination Sites in Hamilton, ON
```

```{r load-data}
 # From package vaccHamilton
data("urban_types")

# Load trained evolutionary trees
load(file = glue::glue(here::here(),
                       "/data/trees.rda"))

# Analysis-ready data. See notebooks in folder data-raw for details
load(file = glue::glue(here::here(),
                       "/data/amenities_walkshed_da.rda"))
load(file = glue::glue(here::here(),
                       "/data/hamilton_net.rda"))
load(file = glue::glue(here::here(),
                       "/data/urban_hammer_da.rda"))
load(file = glue::glue(here::here(),
                       "/data/walksheds_da.rda"))
load(file = glue::glue(here::here(),
                       "/data/walksheds_da_net_vars.rda"))
load(file = glue::glue(here::here(),
                       "/data/walksheds_validation.rda"))
load(file = glue::glue(here::here(),
                       "/data/walksheds_validation_net_vars.rda"))
```

```{r}
# Bind the centroid and non-centroid walksheds:
walksheds <- bind_rows(walksheds_da,
                       walksheds_validation) |>
  mutate(origin_type = rep(c("centroid", "non-centroid"), each = nrow(walksheds_da)))
```

```{r }
# Obtain training and validation datasets by sampling from centroid and non-centroid walksheds:

# Set seed for replicability
seed <- 3626425
set.seed(seed)

# slice_sample() will select one of two rows for each DA at random
walksheds_train <- walksheds |>
  group_by(GeoUID) |>
  slice_sample(prop = 0.5)

# The antijoin will keep the rows in walksheds that do not appear in walksheds_train
walksheds_test <- walksheds |>
  anti_join(walksheds_train |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))
```

```{r bind-centroid-non-centroid-network-variables}
# Bind the centroid and non-centroid dataframes with walkshed network variables:
walksheds_net_vars <- bind_rows(walksheds_da_net_vars,
                                walksheds_validation_net_vars) |>
  mutate(origin_type = rep(c("centroid",
                             "non-centroid"), 
                           each = nrow(walksheds_da)))
```

```{r obtain-training-testing-network-variables}
# Now filter from the network variables to obtain training and test datasets:
walksheds_train_net_vars <- walksheds_net_vars |>
  semi_join(walksheds_train |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))

walksheds_test_net_vars <- walksheds_net_vars |>
  semi_join(walksheds_test |>
              st_drop_geometry() |>
              select(GeoUID, origin_type),
            by = c("GeoUID", "origin_type"))
```

```{r training-and-testing-dataframes-for-evolutionary-tree}
d <- walksheds_train_net_vars |>
  select(-girth) |>
  drop_na() |>
  mutate(normalized_motifs_3 = motifs_3/n_edges,
         normalized_motifs_4 = motifs_4/n_edges)

d_test <- walksheds_test_net_vars |>
  select(-girth) |>
  drop_na() |>
  mutate(normalized_motifs_3 = motifs_3/n_edges,
         normalized_motifs_4 = motifs_4/n_edges)
```

```{r best-tree}
# Retrieve the best evolutionary tree. The algorithm of evolutionary trees has some randomness due to random initial values. We compared a number of trees and chose the one that gave the best fit in terms of missclassification and size of the model. See notebook `05-Walkshed-Profiles.Rmd in folder `data-raw` for details.

best_evtree <- trees[[4]]
```

```{r generate-plot-best-tree}
# Round the labels of the edges. The relevant information is in a dataframe produced by ggparty()
ggparty_plot <- best_evtree |>
  ggparty()

# Round the number of digits and keep the inequality signs
ggparty_data <- ggparty_plot$data |>
  mutate(breaks_label = paste0(substr(breaks_label, 4, 5), 
                               substr(breaks_label,10, 15)),
         splitvar = case_when(splitvar == "edge_density" ~ "Edge Density",
                              splitvar == "transitivity" ~ "Transitivity",
                              splitvar == "normalized_motifs_3" ~ "Normalized Motifs (3)",
                              is.na(splitvar) ~ NA))

# Replace the dataframe in the ggplot object
ggparty_plot$data <- ggparty_data 

evtree_plot <- ggparty_plot +
  geom_edge() +
  geom_node_splitvar(id = "inner", size = 3) +
  # parse should be set to FALSE so the labels do not try to parse the inequality signs
  geom_edge_label(mapping = aes(label = breaks_label),
                  parse = FALSE,
                  size = 2.5) +
  # # pass list to gglist containing all ggplot components we want to plot for each
  # # (default: terminal) node
  geom_node_plot(gglist = list(geom_bar(aes(x = "", fill = Type),
                                        position = position_fill()),
                               xlab(""),
                               ylab(""),
                               scale_fill_manual(name = "Urban fabric type",
                                                 values = c("#FDAE61", "#1A9850")),
                               theme(axis.text.y = element_blank(),
                                     panel.background = element_rect(fill = NA),
                                     axis.ticks = element_blank(),
                                     plot.background =  element_rect(fill = NA)))) +
  geom_node_label(line_list = list(aes(label = paste0("Leaf ", ifelse(id >= 6, id - 3, id - 2)))),
                  line_gpar = list(list(size = 7, parse = F)),
                  ids = "terminal",
                  nudge_x = 0.02,
                  nudge_y = -0.4)
```

```{r plot-evtree, fig.cap="\\label{fig:evolutionary-tree}Results of training evolutionary tree on the attributes of the network. The dependent variable is Urban Fabric, a binary variable with values "Urban" (green) and "Suburban" (orange)"}
evtree_plot

ggsave(evtree_plot,
       file = glue::glue(here::here(),"/plots/evtree.png"),
       width = 7,
       units = "in")
```


# Introduction

> "Il faut oublier la traversée de Paris d'est en ouest en voiture"^[ "We must forget about crossing Paris from east to west by car"]. 
> --Anne Hidalgo

With this declaration during her reelection campaign in 2020, Anne Hidalgo brought international attention to the concept of walkable fifteen-minutes neighborhoods [@alimi2020]. 


<!-- 
Automotive retrofits in traditional city centers:

@bass2019automotive
-->

@knight2018walkable
@liu2022toward
@pozoukidou2021fifteen
@weng2019fifteen

15-minute walking neighborhoods
are studied, and their accessibility levels assessed (positive analysis).
Optimal opportunity landscapes are then used to simulate equivalent opportunity
landscapes throughout the region. Accessibility is then reanalyzed from
the normative perspective of the provision of opportunities. The results of
this analysis are finally correlated to neighborhood network attributes, including
connectivity, centrality, and clustering


# Data

The data used to study 15-minute walking neighborhoods in the city of Hamilton was obtained by extracting relevant attributes of the street network within 15-minute pedestrian sheds. These sheds were calculated for each neighborhood as polygon representations of origin-destination walking time matrices, with a maximum travel time of 15 minutes. Walkshed calculations were generated using the travel_time_matrix function for walking from the {r5r} R package. This process involved defining the street network, as well as the origins and destinations of walking trips. The street network data for these calculations was sourced from OpenStreetMap @OpenStreetMap2023.   

<!--- 
To see the details of the routing see notebook 01-OSM-Network-and-Routing.Rmd in folder data-raw
--->

The origins we established are proxies for the centroids of neighborhoods in the urban and peri-urban areas of the city of Hamilton. Specifically, these are the centroids of Hamilton's Dissemination Areas (DA). A DA is composed of one or more neighboring dissemination blocks and represents the smallest standard geographic area for which all census data are disseminated in Canada. Data on urban and sub-urban boundaries and DAs were retrieved from @HamiltonData2023.

Destinations were established as the centroids of geohashed hexagons within the region of interest, where Hamilton's amenities are located, assuming that presence of amenities is a proxy to provision of opportunities. These destinations were chosen to avoid calculating travel times to each individual amenity. Instead, we used the geohashed polygons as destinations, identifying the amenities within each polygon and assuming that the centroid of each hexagon represents the location of the amenities within it. Specifically, we retrieved geohashing data for Hamilton using the H3 system (SOURCE) and generated child hexagons at resolution 13, with an average area of 43.87 $m^2$. Amenities location and attributes were downloaded from @OpenStreetMap2023.
<!--- 
To see the details of the destinations see notebook 02-OSM-Amenities.Rmd in folder data-raw
--->


# Methods

The proposed method involves studying 15-minute walking neighborhoods in two stages. The first stage assesses accessibility levels from a normative perspective, focusing on the provision of opportunities. In the second stage, the results are correlated with neighborhood network attributes, including connectivity, centrality, and clustering.

## Calculation of accessibility levels

The indicator we use assesses levels of accessibility from a normative perspective, focusing on reachable opportunities as estimates of the potential for spatial interactions @Hansen1959. The advantage of using this form of accessibility analysis in this study is that it has been shown to be a valuable method for exploring the relationship between transportation infrastructure and urban structure @Handy1997.

In this study, we calculate cumulative accessibility scores by summing the number of amenities within urban and suburban walksheds, categorized into four types: financial, sustenance, healthcare, and library.
<!--- 
To see the details of the accessibility calculations see notebook 04-Accessibility-Calculations.Rmd in folder data-raw
--->

## Walkshed network attributes by walkshed

We characterize urban and suburban walksheds by means of their network attributes. We selected 11 of the network attributes from those proposed in R/igraph, a widely used network analysis R library @IgraphManual. 

- Number of vertices.
- Number of edges.
- Diameter.
- Radius.
- Global efficiency: the global efficiency of a network is defined as the average of inverse. distances between all pairs of vertices.´
- Edge density: the density of a graph is the ratio of the actual number of edges and the largest possible number of edges in the graph.
- Mean distance: mean length of all the shortest paths from or to the vertices in the network.
- Girth: the girth of a graph is the length of the shortest circle in it.
Minimum cut of a graph: the minimum total weight of the edges needed to remove to separate the graph into (at least) two components. 
- Edge connectivity: it is a measure of network vulnerability, minimum number of edges to remove to disconnect two nodes (there is no longer a path between them.
- Transitivity: it is the probability that the neighbors of a node are neighbors between them. In a Manhattan-style grid this number will be low because there will be lots and lots of squares.
- Motifs (calculated for size 3 and 4): It indicates the presence of particular subgraphs that repeat themselves. In other words, a graph with a large number of motifs will tend to have few unique elements (some elements happen again, again, and again). A graph with many unique elements will have few motifs (repetitive patterns).
<!--- 
To see the details of the attribute calculations see notebook 03-Network-Attributes-by-Walkshed.Rmd in folder data-raw
--->

## Walkshed classification

To profile urban and suburban walksheds based on the attributes of the network we use a classification tree. In particular We use a technique with evolutionary trees - an alternative to classification trees that is less affected by the greediness of the algorithm. Since evolutionary trees have some randomness (for the initial values), we try several to find whether there are patterns. In this case we use four different random seeds. 

<!--- 
To see the details of walkshed profile calculations see notebook 06-Walkshed-Profiles.Rmd in folder data-raw
--->











# References {-}


